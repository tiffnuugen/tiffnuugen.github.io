---
layout: post
title:      "My Magnum Opus: The React/Redux Final Project"
date:       2020-08-12 23:15:42 +0000
permalink:  my_magnum_opus_the_react_redux_final_project
---


My react/redux final project is my magnum opus, crème de la crème, or in plain english: my best work yet. I am immensely proud yet so burnt out by it, but oddly inspired by the prospect of adding more stretch features to it. Since the amount I have learned from this project is astoundingly unprecedented, I may not be able to cover every aspect of it in full detail, so I'm just going to expand on certain things in a separate blog post if it warrants one. In the meantime, I'm going to try my best to briefly touch on everything I have learned and struggled with. 

Before I get into what I have learned and struggled with, it is paramount that I outline what my app successfully does for full context. First of all, the name of my app is called "Foodcrwlr" and originally I described the user story as the following: "Food enthusiasts of all kinds need a way to not only find good eats but to also connect with each other to go on food crawls together." However, since submitting the project for review, I have not built out the feature that allows users to "connect", which is supposed to be a chat window feature. Due to its complexity, I have decided to designate it as a stretch feature to work on during my job search. Aside from that, the app does exactly what it purports to do with the rest of the user story. A user needs to first login into their account (or signup if they don't have one yet) in order to use the app though. Once logged in, they are immediately shown a list of new and trendy restaurants in New York City on the homepage. They can either click on an individual restaurant right away or if they want, they can search a restaurant by either simply typing in the location—which is required—and term—which can be a type of food or restaurant—in the search bar. After hitting submit, a list of the most relevant restaurants for their search should appear and they can choose a restaurant from there. Navigating to an individual restaurant page shows the user more details about it and that's where they can choose to leave a review and/or save the restaurant. If the user decides to leave a review, they also have the option to edit or even delete it, as well as unsave the restaurant. They finally have the option to view all their saved restaurants and written reviews, and even if they log out, all of their information is still saved!

Now let me go over all of the specific topics/issues that I have struggled with, learned about, and have since overcome over the course of this project: user authentication, redux persist, making calls to the yelp api, restaurant–has_many–reviews association, frontend validations, react router, and displaying user-edited reviews and saving a restaurant. 

For user authentication, I learned how to implement HTTP-only cookies on my rails backend. I partly followed a tutorial for this and was able to figure out how to connect it to my react frontend from there. I think the hardest part of the overall implementation was trying to account for all the cases when the user is not successfully logged in. 

With redux persist, I was trying to save the redux store data to local storage. After reading some of the documentation and posts on it, I started tinkering with configuration for a little bit, and finally was able to do it. 

At first, I thought making calls to the yelp api was straightforward and easy as obtaining the client id and api key, then going wild with the calls from the frontend, but it turns out there was a catch to it. Apparently, I was not aware of the very limited number of calls (100 I believe) that one was allowed to make per hour. It was incredibly frustrating and annoying to hit that limit and having to wait a while to make those calls again—it was a flow killer to say the least. Long story short, the solution was to consume the yelp api from the backend and I think I will go into greater detail about how to do all of that in a separate blog post. 

When it comes to the restaurant–has_many–reviews association, it looks like any run-of-the-mill association and you can simply add the foreign key of restaurant_id to the reviews table to establish the relationship. But what if the restaurant coming from the third-party yelp api has its own unique id? Everytime a user leaves a review for a particular restaurant, in order to properly associate a review to a restaurant without overriding the default primary key id, I had to tell my review and restaurant models to use yelp's unique string id as the primary key.

As for frontend validations, the review form and restaurant form (the search bar) were easiest to do while the login and signup forms were the hardest, especially the latter. However, the key to figuring it out too was breaking it in every possible way and making sure the conditional logic accounted for all of that. 

Dealing with react router was such a struggle as just when I thought I understood it, it turns out I fundamentally didn't. I learned that strategic placement is the name-of-the-game and it concretely taught me what I was doing wrong and why my routes weren't working. Also, the withRouter function is your friend as you will get access to the history, location, and match props, thereby opening up amazing navigational possibilities. As react router is one of those technologies that is easy to implement, but is difficult to understand, I think it warrants its own blog post that will specifically explain how to use it whilst understanding it. 

For the user-edited reviews, whenever a user is done editing their review, the updated text or rating should be shown with an "edited" status like the one that appears in slack after you edit your message. The issue I was initially having with creating this feature though was figuring out how to conditionally render the edited text/rating with the edited status when the user changes their original text/rating versus when no changes are made. I basically solved this issue by adding an edited property to every review object that is set to false by default, then using some conditional logic to only show the edited status when the text/rating is changed. With saving a particular restaurant, I initially thought I could do that by making a post request to the restaurants api endpoint to display the saved restaurant object. However, this would conflict with the same restaurant object that is already associated with an array of review objects. I then tried adding a saved property that was set to false by default to every existing restaurant, but didn't fully go through with it because it seemed more complex than it needed to be at the time. The approach I ended up going with was creating a separate saved_restaurants api endpoint, so whenever a user saves a restaurant, the restaurant object would be posted to that endpoint and if the user unsaves a restaurant, the restaurant object would just be deleted from the api.

Welp, that about wraps up my final project blog post. To some extent, I wrote this with the intention of helping someone out there, whether it's being used as a soundboard to see if their project ideas check out or as a safety valve for expressing frustration or relating to the struggle. Whatever that may be, I am here for it. If anyone reading this has a question or would like more clarification on anything discussed in this post or would like to tell me about their hopes and dreams, please feel free to reach out to me.  



